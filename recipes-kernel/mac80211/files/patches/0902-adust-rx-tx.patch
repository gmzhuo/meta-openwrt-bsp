Index: backports-5.15.8-1/net/mac80211/rx.c
===================================================================
--- backports-5.15.8-1.orig/net/mac80211/rx.c
+++ backports-5.15.8-1/net/mac80211/rx.c
@@ -33,6 +33,8 @@
 #include "wme.h"
 #include "rate.h"
 
+#define RX_PASS_THROUGH		((__force ieee80211_rx_result) 5u)
+
 /*
  * monitor mode reception
  *
@@ -2094,7 +2094,7 @@ ieee80211_rx_h_decrypt(struct ieee80211_rx_data *rx)
 
 		/* TODO: add threshold stuff again */
 	} else {
-		return RX_DROP_MONITOR;
+		return RX_PASS_THROUGH;
 	}
 
 	switch (rx->key->conf.cipher) {
@@ -3866,6 +3868,45 @@ static void ieee80211_rx_cooked_monitor(
 	dev_kfree_skb(skb);
 }
 
+static void ieee80211_rx_path_through(struct ieee80211_rx_data *rx,
+					struct ieee80211_rate *rate)
+{
+	struct ieee80211_local *local = rx->local;
+	struct sk_buff *skb = rx->skb;
+	struct net_device *dev = rx->sdata->dev;
+
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	int needed_headroom;
+
+	/* vendor data is long removed here */
+	status->flag &= ~RX_FLAG_RADIOTAP_VENDOR_DATA;
+	/* room for the radiotap header based on driver features */
+	needed_headroom = ieee80211_rx_radiotap_hdrlen(local, status, skb);
+
+	if (skb_headroom(skb) < needed_headroom &&
+	    pskb_expand_head(skb, needed_headroom, 0, GFP_ATOMIC))
+		goto out_free_skb;
+
+	/* prepend radiotap information */
+	ieee80211_add_rx_radiotap_header(local, skb, rate, needed_headroom,
+					 false);
+
+	skb_reset_mac_header(skb);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+
+	if(dev) {
+		dev_sw_netstats_rx_add(dev, skb->len);
+		skb->dev = dev;
+		netif_receive_skb(skb);
+		return;
+	}
+
+out_free_skb:
+	dev_kfree_skb(skb);
+}
+
 static void ieee80211_rx_handlers_result(struct ieee80211_rx_data *rx,
 					 ieee80211_rx_result res)
 {
@@ -3889,6 +3930,20 @@ static void ieee80211_rx_handlers_result
 		ieee80211_rx_cooked_monitor(rx, rate);
 		break;
 		}
+	case RX_PASS_THROUGH: {
+		struct ieee80211_rate *rate = NULL;
+		struct ieee80211_supported_band *sband;
+		struct ieee80211_rx_status *status;
+
+		status = IEEE80211_SKB_RXCB((rx->skb));
+
+		sband = rx->local->hw.wiphy->bands[status->band];
+		if (status->encoding == RX_ENC_LEGACY)
+			rate = &sband->bitrates[status->rate_idx];
+
+		ieee80211_rx_path_through(rx, rate);
+		break;
+		}
 	case RX_DROP_UNUSABLE:
 		I802_DEBUG_INC(rx->sdata->local->rx_handlers_drop);
 		if (rx->sta)
Index: backports-5.15.8-1/net/mac80211/tx.c
===================================================================
--- backports-5.15.8-1.orig/net/mac80211/tx.c
+++ backports-5.15.8-1/net/mac80211/tx.c
@@ -4157,6 +4157,9 @@ void ieee80211_txq_schedule_start(struct
 }
 EXPORT_SYMBOL(ieee80211_txq_schedule_start);
 
+
+#define ETH_P_80211 0x0055
+
 void __ieee80211_subif_start_xmit(struct sk_buff *skb,
 				  struct net_device *dev,
 				  u32 info_flags,
@@ -4230,16 +4233,49 @@ void __ieee80211_subif_start_xmit(struct
 	}
 
 	skb_list_walk_safe(skb, skb, next) {
+		struct ethhdr *ehdr = (struct ethhdr *)skb->data;
 		skb_mark_not_on_list(skb);
 
 		if (skb->protocol == sdata->control_port_protocol)
 			ctrl_flags |= IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP;
 
-		skb = ieee80211_build_hdr(sdata, skb, info_flags,
-					  sta, ctrl_flags, cookie);
-		if (IS_ERR(skb)) {
-			kfree_skb_list(next);
-			goto out;
+		if((skb->protocol == __constant_htons(ETH_P_80211)) &&
+			ehdr->h_proto != __constant_htons(ETH_P_PAE)) {
+			struct ieee80211_tx_info *info;
+			struct ieee80211_sub_if_data *ap_sdata;
+			struct ieee80211_chanctx_conf *chanctx_conf;
+			enum nl80211_band band;
+			u16 info_id = 0;
+
+			ap_sdata = container_of(sdata->bss, struct ieee80211_sub_if_data,
+					u.ap);
+			chanctx_conf = rcu_dereference(ap_sdata->vif.chanctx_conf);
+			if (!chanctx_conf) {
+				kfree_skb(skb);
+				kfree_skb_list(next);
+				goto out;
+			}
+
+			band = chanctx_conf->def.chan->band;
+
+			info = IEEE80211_SKB_CB(skb);
+			memset(info, 0, sizeof(*info));
+
+			//set some flags here
+			info->flags = info_flags;
+			info->ack_frame_id = info_id;
+			info->band = band;
+			info->control.flags = ctrl_flags;
+
+			info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
+				IEEE80211_TX_CTL_DONTFRAG;
+		} else {
+			skb = ieee80211_build_hdr(sdata, skb, info_flags,
+						  sta, ctrl_flags, cookie);
+			if (IS_ERR(skb)) {
+				kfree_skb_list(next);
+				goto out;
+			}
 		}
 
 		dev_sw_netstats_tx_add(dev, 1, skb->len);
@@ -4516,6 +4552,11 @@ netdev_tx_t ieee80211_subif_start_xmit_8
 
 	rcu_read_lock();
 
+	if((skb->protocol == __constant_htons(ETH_P_80211)) &&
+			ehdr->h_proto != __constant_htons(ETH_P_PAE)) {
+		goto skip_offload;
+	}
+
 	if (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {
 		kfree_skb(skb);
 		goto out;
