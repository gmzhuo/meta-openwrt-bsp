Index: backports-5.15.8-1/net/mac80211/rx.c
===================================================================
--- backports-5.15.8-1.orig/net/mac80211/rx.c
+++ backports-5.15.8-1/net/mac80211/rx.c
@@ -2092,6 +2092,13 @@ ieee80211_rx_h_decrypt(struct ieee80211_
 
 		/* TODO: add threshold stuff again */
 	} else {
+#define ETH_P_80211 0x0055
+		//here we deliver to netif  rx
+		skb = skb_clone(skb, GFP_ATOMIC);
+		if(skb) {
+			skb->protocol = __constant_htons(ETH_P_80211);
+			netif_receive_skb(skb);
+		}
 		return RX_DROP_MONITOR;
 	}
 
Index: backports-5.15.8-1/net/mac80211/tx.c
===================================================================
--- backports-5.15.8-1.orig/net/mac80211/tx.c
+++ backports-5.15.8-1/net/mac80211/tx.c
@@ -4157,6 +4157,9 @@ void ieee80211_txq_schedule_start(struct
 }
 EXPORT_SYMBOL(ieee80211_txq_schedule_start);
 
+
+#define ETH_P_80211 0x0055
+
 void __ieee80211_subif_start_xmit(struct sk_buff *skb,
 				  struct net_device *dev,
 				  u32 info_flags,
@@ -4230,16 +4233,49 @@ void __ieee80211_subif_start_xmit(struct
 	}
 
 	skb_list_walk_safe(skb, skb, next) {
+		struct ethhdr *ehdr = (struct ethhdr *)skb->data;
 		skb_mark_not_on_list(skb);
 
 		if (skb->protocol == sdata->control_port_protocol)
 			ctrl_flags |= IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP;
 
-		skb = ieee80211_build_hdr(sdata, skb, info_flags,
-					  sta, ctrl_flags, cookie);
-		if (IS_ERR(skb)) {
-			kfree_skb_list(next);
-			goto out;
+		if((skb->protocol == __constant_htons(ETH_P_80211)) &&
+			ehdr->h_proto != __constant_htons(ETH_P_PAE)) {
+			struct ieee80211_tx_info *info;
+			struct ieee80211_sub_if_data *ap_sdata;
+			struct ieee80211_chanctx_conf *chanctx_conf;
+			enum nl80211_band band;
+			u16 info_id = 0;
+
+			ap_sdata = container_of(sdata->bss, struct ieee80211_sub_if_data,
+					u.ap);
+			chanctx_conf = rcu_dereference(ap_sdata->vif.chanctx_conf);
+			if (!chanctx_conf) {
+				kfree_skb(skb);
+				kfree_skb_list(next);
+				goto out;
+			}
+
+			band = chanctx_conf->def.chan->band;
+
+			info = IEEE80211_SKB_CB(skb);
+			memset(info, 0, sizeof(*info));
+
+			//set some flags here
+			info->flags = info_flags;
+			info->ack_frame_id = info_id;
+			info->band = band;
+			info->control.flags = ctrl_flags;
+
+			info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
+				IEEE80211_TX_CTL_DONTFRAG;
+		} else {
+			skb = ieee80211_build_hdr(sdata, skb, info_flags,
+						  sta, ctrl_flags, cookie);
+			if (IS_ERR(skb)) {
+				kfree_skb_list(next);
+				goto out;
+			}
 		}
 
 		dev_sw_netstats_tx_add(dev, 1, skb->len);
@@ -4516,6 +4552,11 @@ netdev_tx_t ieee80211_subif_start_xmit_8
 
 	rcu_read_lock();
 
+	if((skb->protocol == __constant_htons(ETH_P_80211)) &&
+			ehdr->h_proto != __constant_htons(ETH_P_PAE)) {
+		goto skip_offload;
+	}
+
 	if (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {
 		kfree_skb(skb);
 		goto out;
