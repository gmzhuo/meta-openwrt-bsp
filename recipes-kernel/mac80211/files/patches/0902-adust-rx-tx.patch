Index: backports-5.15.8-1/net/mac80211/rx.c
===================================================================
--- backports-5.15.8-1.orig/net/mac80211/rx.c
+++ backports-5.15.8-1/net/mac80211/rx.c
@@ -33,6 +33,9 @@
 #include "wme.h"
 #include "rate.h"
 
+#define RX_PASS_THROUGH		((__force ieee80211_rx_result) 5u)
+#define IEEE80211_RX_PASS_THROUGH BIT(2)
+
 /*
  * monitor mode reception
  *
@@ -2092,7 +2095,7 @@ ieee80211_rx_h_decrypt(struct ieee80211_
 
 		/* TODO: add threshold stuff again */
 	} else {
-		return RX_DROP_MONITOR;
+		return RX_PASS_THROUGH;
 	}
 
 	switch (rx->key->conf.cipher) {
@@ -3815,7 +3818,7 @@ static void ieee80211_rx_cooked_monitor(
 	rx->flags |= IEEE80211_RX_CMNTR;
 
 	/* If there are no cooked monitor interfaces, just free the SKB */
-	if (!local->cooked_mntrs)
+	if (!local->cooked_mntrs && !(rx->flags & IEEE80211_RX_PASS_THROUGH))
 		goto out_free_skb;
 
 	/* vendor data is long removed here */
@@ -3836,6 +3839,13 @@ static void ieee80211_rx_cooked_monitor(
 	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = htons(ETH_P_802_2);
 
+	if(rx->flags & IEEE80211_RX_PASS_THROUGH) {
+		prev_dev = rx->sdata->dev;
+		if(prev_dev) {
+			dev_sw_netstats_rx_add(prev_dev, skb->len);
+		}
+	}
+
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
 		if (!ieee80211_sdata_running(sdata))
 			continue;
@@ -3875,6 +3885,9 @@ static void ieee80211_rx_handlers_result
 		if (rx->sta)
 			rx->sta->rx_stats.dropped++;
 		fallthrough;
+	case RX_PASS_THROUGH:
+		rx->flags |= IEEE80211_RX_PASS_THROUGH;
+		fallthrough;
 	case RX_CONTINUE: {
 		struct ieee80211_rate *rate = NULL;
 		struct ieee80211_supported_band *sband;
Index: backports-5.15.8-1/net/mac80211/tx.c
===================================================================
--- backports-5.15.8-1.orig/net/mac80211/tx.c
+++ backports-5.15.8-1/net/mac80211/tx.c
@@ -4157,6 +4157,9 @@ void ieee80211_txq_schedule_start(struct
 }
 EXPORT_SYMBOL(ieee80211_txq_schedule_start);
 
+
+#define ETH_P_80211 0x0055
+
 void __ieee80211_subif_start_xmit(struct sk_buff *skb,
 				  struct net_device *dev,
 				  u32 info_flags,
@@ -4230,16 +4233,49 @@ void __ieee80211_subif_start_xmit(struct
 	}
 
 	skb_list_walk_safe(skb, skb, next) {
+		struct ethhdr *ehdr = (struct ethhdr *)skb->data;
 		skb_mark_not_on_list(skb);
 
 		if (skb->protocol == sdata->control_port_protocol)
 			ctrl_flags |= IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP;
 
-		skb = ieee80211_build_hdr(sdata, skb, info_flags,
-					  sta, ctrl_flags, cookie);
-		if (IS_ERR(skb)) {
-			kfree_skb_list(next);
-			goto out;
+		if((skb->protocol == __constant_htons(ETH_P_80211)) &&
+			ehdr->h_proto != __constant_htons(ETH_P_PAE)) {
+			struct ieee80211_tx_info *info;
+			struct ieee80211_sub_if_data *ap_sdata;
+			struct ieee80211_chanctx_conf *chanctx_conf;
+			enum nl80211_band band;
+			u16 info_id = 0;
+
+			ap_sdata = container_of(sdata->bss, struct ieee80211_sub_if_data,
+					u.ap);
+			chanctx_conf = rcu_dereference(ap_sdata->vif.chanctx_conf);
+			if (!chanctx_conf) {
+				kfree_skb(skb);
+				kfree_skb_list(next);
+				goto out;
+			}
+
+			band = chanctx_conf->def.chan->band;
+
+			info = IEEE80211_SKB_CB(skb);
+			memset(info, 0, sizeof(*info));
+
+			//set some flags here
+			info->flags = info_flags;
+			info->ack_frame_id = info_id;
+			info->band = band;
+			info->control.flags = ctrl_flags;
+
+			info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
+				IEEE80211_TX_CTL_DONTFRAG;
+		} else {
+			skb = ieee80211_build_hdr(sdata, skb, info_flags,
+						  sta, ctrl_flags, cookie);
+			if (IS_ERR(skb)) {
+				kfree_skb_list(next);
+				goto out;
+			}
 		}
 
 		dev_sw_netstats_tx_add(dev, 1, skb->len);
@@ -4516,6 +4552,11 @@ netdev_tx_t ieee80211_subif_start_xmit_8
 
 	rcu_read_lock();
 
+	if((skb->protocol == __constant_htons(ETH_P_80211)) &&
+			ehdr->h_proto != __constant_htons(ETH_P_PAE)) {
+		goto skip_offload;
+	}
+
 	if (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {
 		kfree_skb(skb);
 		goto out;
