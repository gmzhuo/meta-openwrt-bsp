Index: backports-5.15.8-1/net/wireless/nl80211.c
===================================================================
--- backports-5.15.8-1.orig/net/wireless/nl80211.c
+++ backports-5.15.8-1/net/wireless/nl80211.c
@@ -4945,6 +4945,498 @@ out:
 	return 0;
 }
 
+static void dump_hex(const char *name, const unsigned char *hex, int len)
+{
+	static char buf[8192] = {0};
+	int j;
+	buf[0] = 0;
+	for(j = 0; j < len; ++j) {
+		sprintf(buf + j * 2, "%02X", hex[j]);
+	}
+
+	printk("%s %s\r\n", name, buf);
+}
+
+#define NL80211_ATTR_DEFINE(X) [X] = #X
+
+static const char *nl80211_attrs[] =
+{
+	NL80211_ATTR_DEFINE(NL80211_ATTR_UNSPEC),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_NAME),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_IFINDEX),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_IFNAME),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_IFTYPE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAC),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEY_DATA),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEY_IDX),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEY_CIPHER),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEY_SEQ),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEY_DEFAULT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BEACON_INTERVAL),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_DTIM_PERIOD),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BEACON_HEAD),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BEACON_TAIL),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_AID),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_FLAGS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_LISTEN_INTERVAL),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_SUPPORTED_RATES),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_VLAN),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_INFO),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_BANDS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MNTR_FLAGS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MESH_ID),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_PLINK_ACTION),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MPATH_NEXT_HOP),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MPATH_INFO),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BSS_CTS_PROT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BSS_SHORT_PREAMBLE),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BSS_SHORT_SLOT_TIME),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_HT_CAPABILITY),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SUPPORTED_IFTYPES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_REG_ALPHA2),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_REG_RULES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MESH_CONFIG),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BSS_BASIC_RATES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_TXQ_PARAMS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_FREQ),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_CHANNEL_TYPE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEY_DEFAULT_MGMT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MGMT_SUBTYPE),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_IE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_NUM_SCAN_SSIDS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCAN_FREQUENCIES),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCAN_SSIDS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_GENERATION), /* replaces old SCAN_GENERATION */
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BSS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_REG_INITIATOR),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_REG_TYPE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SUPPORTED_COMMANDS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FRAME),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SSID),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_AUTH_TYPE),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_REASON_CODE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEY_TYPE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_SCAN_IE_LEN),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CIPHER_SUITES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FREQ_BEFORE),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FREQ_AFTER),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FREQ_FIXED),
+
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_RETRY_SHORT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_RETRY_LONG),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_FRAG_THRESHOLD),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_RTS_THRESHOLD),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TIMED_OUT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_USE_MFP),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_FLAGS2),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CONTROL_PORT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TESTDATA),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PRIVACY),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_DISCONNECTED_BY_AP),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STATUS_CODE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CIPHER_SUITES_PAIRWISE),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CIPHER_SUITE_GROUP),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WPA_VERSIONS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_AKM_SUITES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_REQ_IE),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_RESP_IE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PREV_BSSID),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEY),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEYS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PID),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_4ADDR),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SURVEY_INFO),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PMKID),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_NUM_PMKIDS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_DURATION),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_COOKIE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_COVERAGE_CLASS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TX_RATES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FRAME_MATCH),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_ACK),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PS_STATE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CQM),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_LOCAL_STATE_CHANGE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_AP_ISOLATE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_TX_POWER_SETTING),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_TX_POWER_LEVEL),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TX_FRAME_TYPES),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_RX_FRAME_TYPES),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FRAME_TYPE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CONTROL_PORT_ETHERTYPE),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SUPPORT_IBSS_RSN),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_ANTENNA_TX),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_ANTENNA_RX),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MCAST_RATE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_OFFCHANNEL_TX_OK),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BSS_HT_OPMODE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_KEY_DEFAULT_TYPES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MESH_SETUP),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SUPPORT_MESH_AUTH),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_PLINK_STATE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WOWLAN_TRIGGERS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCHED_SCAN_INTERVAL),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_INTERFACE_COMBINATIONS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SOFTWARE_IFTYPES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_REKEY_DATA),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCAN_SUPP_RATES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_HIDDEN_SSID),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_IE_PROBE_RESP),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_IE_ASSOC_RESP),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_WME),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SUPPORT_AP_UAPSD),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_ROAM_SUPPORT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCHED_SCAN_MATCH),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_MATCH_SETS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PMKSA_CANDIDATE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TX_NO_CCK_RATE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TDLS_ACTION),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TDLS_DIALOG_TOKEN),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TDLS_OPERATION),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TDLS_SUPPORT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TDLS_EXTERNAL_SETUP),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_DEVICE_AP_SME),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_DONT_WAIT_FOR_ACK),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FEATURE_FLAGS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PROBE_RESP_OFFLOAD),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PROBE_RESP),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_DFS_REGION),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_DISABLE_HT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_HT_CAPABILITY_MASK),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_NOACK_MAP),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_INACTIVITY_TIMEOUT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_RX_SIGNAL_DBM),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BG_SCAN_PERIOD),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WDEV),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_USER_REG_HINT_TYPE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CONN_FAILED_REASON),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_AUTH_DATA),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_VHT_CAPABILITY),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCAN_FLAGS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CHANNEL_WIDTH),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CENTER_FREQ1),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CENTER_FREQ2),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_P2P_CTWINDOW),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_P2P_OPPPS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_LOCAL_MESH_POWER_MODE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_ACL_POLICY),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAC_ADDRS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAC_ACL_MAX),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_RADAR_EVENT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_EXT_CAPA),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_EXT_CAPA_MASK),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_CAPABILITY),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_EXT_CAPABILITY),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PROTOCOL_FEATURES),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SPLIT_WIPHY_DUMP),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_DISABLE_VHT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_VHT_CAPABILITY_MASK),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MDID),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_IE_RIC),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CRIT_PROT_ID),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_CRIT_PROT_DURATION),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PEER_AID),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_COALESCE_RULE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CH_SWITCH_COUNT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CH_SWITCH_BLOCK_TX),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CSA_IES),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CSA_C_OFF_BEACON),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CSA_C_OFF_PRESP),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_RXMGMT_FLAGS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_SUPPORTED_CHANNELS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_HANDLE_DFS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SUPPORT_5_MHZ),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SUPPORT_10_MHZ),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_OPMODE_NOTIF),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_VENDOR_ID),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_VENDOR_SUBCMD),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_VENDOR_DATA),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_VENDOR_EVENTS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_QOS_MAP),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAC_HINT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_FREQ_HINT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_AP_ASSOC_STA),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TDLS_PEER_CAPABILITY),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SOCKET_OWNER),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CSA_C_OFFSETS_TX),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_CSA_COUNTERS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TDLS_INITIATOR),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_USE_RRM),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_DYN_ACK),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TSID),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_USER_PRIO),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_ADMITTED_TIME),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SMPS_MODE),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_OPER_CLASS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAC_MASK),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_SELF_MANAGED_REG),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_EXT_FEATURES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SURVEY_RADIO_STATS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_NETNS_FD),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCHED_SCAN_DELAY),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_REG_INDOOR),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCHED_SCAN_PLANS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PBSS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BSS_SELECT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_STA_SUPPORT_P2P_PS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PAD),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_IFTYPE_EXT_CAPA),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MU_MIMO_GROUP_DATA),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCAN_START_TIME_TSF),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCAN_START_TIME_TSF_BSSID),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MEASUREMENT_DURATION),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MESH_PEER_AID),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_NAN_MASTER_PREF),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BANDS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_NAN_FUNC),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_NAN_MATCH),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FILS_KEK),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FILS_NONCES),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_BSSID),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TIMEOUT_REASON),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FILS_ERP_USERNAME),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FILS_ERP_REALM),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FILS_ERP_RRK),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FILS_CACHE_ID),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PMK),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCHED_SCAN_MULTI),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_SCHED_SCAN_MAX_REQS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WANT_1X_4WAY_HS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PMKR0_NAME),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PORT_AUTHORIZED),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_EXTERNAL_AUTH_ACTION),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_EXTERNAL_AUTH_SUPPORT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_NSS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_ACK_SIGNAL),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_CONTROL_PORT_OVER_NL80211),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TXQ_STATS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TXQ_LIMIT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TXQ_MEMORY_LIMIT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TXQ_QUANTUM),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_HE_CAPABILITY),
+
+	/* not backported yet */
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FTM_RESPONDER),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_FTM_RESPONDER_STATS),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_TIMEOUT),
+	NL80211_ATTR_DEFINE(NL80211_ATTR_PEER_MEASUREMENTS),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_AIRTIME_WEIGHT),
+
+	NL80211_ATTR_DEFINE(NL80211_ATTR_WIPHY_ANTENNA_GAIN),
+
+	/* add attributes here), update the policy in nl80211.c */
+
+	NL80211_ATTR_DEFINE(__NL80211_ATTR_AFTER_LAST),
+};
+
+static void dump_nlattr(struct nlattr *attr)
+{
+	printk("attr %d %d:", attr->nla_type, attr->nla_len);
+
+	if(NLA_F_NESTED & attr->nla_type) {
+		int rem = attr->nla_len;
+		struct nlattr *pos;
+		printk("\r\n");
+		nla_for_each_nested(pos, attr, rem) {
+			dump_nlattr(pos);
+		}
+	} else {
+		dump_hex(nl80211_attrs[attr->nla_type]?:"unknow", (const unsigned char *)(attr + 1), (attr->nla_len - 4));
+	}
+}
+
+static void dump_genlinfo(struct genl_info *info)
+{
+	int j = 0;
+	for(j = 0; j < NUM_NL80211_ATTR; ++j) {
+		if(info->attrs[j]) {
+			dump_nlattr(info->attrs[j]);
+		}
+	}
+}
+
 static int validate_beacon_tx_rate(struct cfg80211_registered_device *rdev,
 				   enum nl80211_band band,
 				   struct cfg80211_bitrate_mask *beacon_rate)
@@ -5365,26 +5857,36 @@ static int nl80211_start_ap(struct sk_bu
 	int err;
 
 	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&
-	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
+	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {
+		printk("in nl80211_start_ap EOPNOTSUPP when check iftype\r\n");
 		return -EOPNOTSUPP;
+	}
 
-	if (!rdev->ops->start_ap)
+	if (!rdev->ops->start_ap) {
+		printk("in nl80211_start_ap EOPNOTSUPP when check ops->start_ap\r\n");
 		return -EOPNOTSUPP;
+	}
 
-	if (wdev->beacon_interval)
+	if (wdev->beacon_interval) {
+		printk("in nl80211_start_ap EOPNOTSUPP when check beacon_interval\r\n");
 		return -EALREADY;
+	}
 
 	memset(&params, 0, sizeof(params));
 
 	/* these are required for START_AP */
 	if (!info->attrs[NL80211_ATTR_BEACON_INTERVAL] ||
 	    !info->attrs[NL80211_ATTR_DTIM_PERIOD] ||
-	    !info->attrs[NL80211_ATTR_BEACON_HEAD])
+	    !info->attrs[NL80211_ATTR_BEACON_HEAD]) {
+		printk("in nl80211_start_ap EOPNOTSUPP when check beacon_interval dtim period beacon head\r\n");
 		return -EINVAL;
+	}
 
 	err = nl80211_parse_beacon(rdev, info->attrs, &params.beacon);
-	if (err)
+	if (err) {
+		printk("in nl80211_start_ap EOPNOTSUPP when check validate beacon\r\n");
 		return err;
+	}
 
 	params.beacon_interval =
 		nla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);
@@ -5393,8 +5895,10 @@ static int nl80211_start_ap(struct sk_bu
 
 	err = cfg80211_validate_beacon_int(rdev, dev->ieee80211_ptr->iftype,
 					   params.beacon_interval);
-	if (err)
+	if (err) {
+		printk("in nl80211_start_ap EOPNOTSUPP when check validate beacon interval\r\n");
 		return err;
+	}
 
 	/*
 	 * In theory, some of these attributes should be required here
@@ -5407,8 +5911,10 @@ static int nl80211_start_ap(struct sk_bu
 		params.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);
 		params.ssid_len =
 			nla_len(info->attrs[NL80211_ATTR_SSID]);
-		if (params.ssid_len == 0)
+		if (params.ssid_len == 0) {
+			printk("in nl80211_start_ap EOPNOTSUPP when check bssid len\r\n");
 			return -EINVAL;
+		}
 	}
 
 	if (info->attrs[NL80211_ATTR_HIDDEN_SSID])
@@ -5421,15 +5927,19 @@ static int nl80211_start_ap(struct sk_bu
 		params.auth_type = nla_get_u32(
 			info->attrs[NL80211_ATTR_AUTH_TYPE]);
 		if (!nl80211_valid_auth_type(rdev, params.auth_type,
-					     NL80211_CMD_START_AP))
+					     NL80211_CMD_START_AP)) {
+			printk("in nl80211_start_ap EOPNOTSUPP when check auth type\r\n");
 			return -EINVAL;
+		}
 	} else
 		params.auth_type = NL80211_AUTHTYPE_AUTOMATIC;
 
 	err = nl80211_crypto_settings(rdev, info, &params.crypto,
 				      NL80211_MAX_NR_CIPHER_SUITES);
-	if (err)
+	if (err) {
+		printk("in nl80211_start_ap EOPNOTSUPP when check crypto settings\r\n");
 		return err;
+	}
 
 	if (info->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]) {
 		if (!(rdev->wiphy.features & NL80211_FEATURE_INACTIVITY_TIMER))
@@ -5439,8 +5949,10 @@ static int nl80211_start_ap(struct sk_bu
 	}
 
 	if (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {
-		if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
+		if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {
+			printk("in nl80211_start_ap EOPNOTSUPP when check iftype for P2P\r\n");
 			return -EINVAL;
+		}
 		params.p2p_ctwindow =
 			nla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);
 		if (params.p2p_ctwindow != 0 &&
@@ -5462,12 +5974,16 @@ static int nl80211_start_ap(struct sk_bu
 
 	if (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {
 		err = nl80211_parse_chandef(rdev, info, &params.chandef);
-		if (err)
+		if (err) {
+			printk("in nl80211_start_ap EOPNOTSUPP when check WIFI FREQ\r\n");
 			return err;
+		}
 	} else if (wdev->preset_chandef.chan) {
 		params.chandef = wdev->preset_chandef;
-	} else if (!nl80211_get_ap_channel(rdev, &params))
+	} else if (!nl80211_get_ap_channel(rdev, &params)) {
+		printk("in nl80211_start_ap EOPNOTSUPP when check channel\r\n");
 		return -EINVAL;
+	}
 
 	if (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,
 					   wdev->iftype))
@@ -5483,8 +5999,10 @@ static int nl80211_start_ap(struct sk_bu
 
 		err = validate_beacon_tx_rate(rdev, params.chandef.chan->band,
 					      &params.beacon_rate);
-		if (err)
+		if (err) {
+			printk("in nl80211_start_ap EOPNOTSUPP when check validate_beacon_tx_rate\r\n");
 			return err;
+		}
 	}
 
 	if (info->attrs[NL80211_ATTR_SMPS_MODE]) {
@@ -5495,13 +6013,17 @@ static int nl80211_start_ap(struct sk_bu
 			break;
 		case NL80211_SMPS_STATIC:
 			if (!(rdev->wiphy.features &
-			      NL80211_FEATURE_STATIC_SMPS))
+			      NL80211_FEATURE_STATIC_SMPS)) {
+				printk("in nl80211_start_ap EOPNOTSUPP when check NL80211_FEATURE_STATIC_SMPS\r\n");
 				return -EINVAL;
+			}
 			break;
 		case NL80211_SMPS_DYNAMIC:
 			if (!(rdev->wiphy.features &
-			      NL80211_FEATURE_DYNAMIC_SMPS))
+			      NL80211_FEATURE_DYNAMIC_SMPS)) {
+				printk("in nl80211_start_ap EOPNOTSUPP when check NL80211_FEATURE_DYNAMIC_SMPS\r\n");
 				return -EINVAL;
+			}
 			break;
 		default:
 			return -EINVAL;
@@ -5511,13 +6033,17 @@ static int nl80211_start_ap(struct sk_bu
 	}
 
 	params.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);
-	if (params.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ])
+	if (params.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ]) {
+		printk("in nl80211_start_ap EOPNOTSUPP when check NL80211_ATTR_PBSS band not support for 60G\r\n");
 		return -EOPNOTSUPP;
+	}
 
 	if (info->attrs[NL80211_ATTR_ACL_POLICY]) {
 		params.acl = parse_acl_data(&rdev->wiphy, info);
-		if (IS_ERR(params.acl))
+		if (IS_ERR(params.acl)) {
+			printk("in nl80211_start_ap EOPNOTSUPP when check failed to get acl\r\n");
 			return PTR_ERR(params.acl);
+		}
 	}
 
 	params.twt_responder =
@@ -5527,32 +6053,40 @@ static int nl80211_start_ap(struct sk_bu
 		err = nl80211_parse_he_obss_pd(
 					info->attrs[NL80211_ATTR_HE_OBSS_PD],
 					&params.he_obss_pd);
-		if (err)
+		if (err) {
+			printk("in nl80211_start_ap nl80211_parse_he_obss_pd\r\n");
 			goto out;
+		}
 	}
 
 	if (info->attrs[NL80211_ATTR_HE_BSS_COLOR]) {
 		err = nl80211_parse_he_bss_color(
 					info->attrs[NL80211_ATTR_HE_BSS_COLOR],
 					&params.he_bss_color);
-		if (err)
+		if (err) {
+			printk("in nl80211_start_ap nl80211_parse_he_bss_color\r\n");
 			goto out;
+		}
 	}
 
 	if (info->attrs[NL80211_ATTR_FILS_DISCOVERY]) {
 		err = nl80211_parse_fils_discovery(rdev,
 						   info->attrs[NL80211_ATTR_FILS_DISCOVERY],
 						   &params);
-		if (err)
+		if (err) {
+			printk("in nl80211_start_ap nl80211_parse_fils_discovery\r\n");
 			goto out;
+		}
 	}
 
 	if (info->attrs[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP]) {
 		err = nl80211_parse_unsol_bcast_probe_resp(
 			rdev, info->attrs[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP],
 			&params);
-		if (err)
+		if (err) {
+			printk("in nl80211_start_ap nl80211_parse_unsol_bcast_probe_resp\r\n");
 			goto out;
+		}
 	}
 
 	nl80211_calculate_ap_params(&params);
@@ -5562,6 +6096,7 @@ static int nl80211_start_ap(struct sk_bu
 
 	wdev_lock(wdev);
 	err = rdev_start_ap(rdev, dev, &params);
+	printk("in nl80211_start_ap rdev_start_ap result %d\r\n", err);
 	if (!err) {
 		wdev->preset_chandef = params.chandef;
 		wdev->beacon_interval = params.beacon_interval;
@@ -9904,8 +10439,10 @@ static int nl80211_crypto_settings(struc
 			info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);
 		settings->control_port_ethertype = cpu_to_be16(proto);
 		if (!(rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&
-		    proto != ETH_P_PAE)
+		    proto != ETH_P_PAE) {
+			printk("in nl80211_crypto_settings check proto\r\n");
 			return -EINVAL;
+		}
 		if (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT])
 			settings->control_port_no_encrypt = true;
 	} else
@@ -9914,8 +10451,10 @@ static int nl80211_crypto_settings(struc
 	if (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {
 		int r = validate_pae_over_nl80211(rdev, info);
 
-		if (r < 0)
+		if (r < 0) {
+			printk("in nl80211_crypto_settings check validate_pae_over_nl80211\r\n");
 			return r;
+		}
 
 		settings->control_port_over_nl80211 = true;
 
@@ -9931,19 +10470,25 @@ static int nl80211_crypto_settings(struc
 		len = nla_len(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);
 		settings->n_ciphers_pairwise = len / sizeof(u32);
 
-		if (len % sizeof(u32))
+		if (len % sizeof(u32)) {
+			printk("in nl80211_crypto_settings check SUITES_PAIRWISE not align 32bit\r\n");
 			return -EINVAL;
+		}
 
-		if (settings->n_ciphers_pairwise > cipher_limit)
+		if (settings->n_ciphers_pairwise > cipher_limit) {
+			printk("in nl80211_crypto_settings check pairwise exceeds cipher_limit\r\n");
 			return -EINVAL;
+		}
 
 		memcpy(settings->ciphers_pairwise, data, len);
 
 		for (i = 0; i < settings->n_ciphers_pairwise; i++)
 			if (!cfg80211_supported_cipher_suite(
 					&rdev->wiphy,
-					settings->ciphers_pairwise[i]))
+					settings->ciphers_pairwise[i])) {
+				printk("in nl80211_crypto_settings not support ciphers_pairwise %08x\r\n", settings->ciphers_pairwise[i]);
 				return -EINVAL;
+			}
 	}
 
 	if (info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]) {
@@ -9951,14 +10496,19 @@ static int nl80211_crypto_settings(struc
 			nla_get_u32(info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]);
 		if (!cfg80211_supported_cipher_suite(&rdev->wiphy,
 						     settings->cipher_group))
+		{
+			printk("in nl80211_crypto_settings not support cipher_group %08x\r\n", settings->cipher_group);
 			return -EINVAL;
+		}
 	}
 
 	if (info->attrs[NL80211_ATTR_WPA_VERSIONS]) {
 		settings->wpa_versions =
 			nla_get_u32(info->attrs[NL80211_ATTR_WPA_VERSIONS]);
-		if (!nl80211_valid_wpa_versions(settings->wpa_versions))
+		if (!nl80211_valid_wpa_versions(settings->wpa_versions)) {
+			printk("in nl80211_crypto_settings not support wpa_versions %d\r\n", settings->wpa_versions);
 			return -EINVAL;
+		}
 	}
 
 	if (info->attrs[NL80211_ATTR_AKM_SUITES]) {
@@ -9969,23 +10519,31 @@ static int nl80211_crypto_settings(struc
 		len = nla_len(info->attrs[NL80211_ATTR_AKM_SUITES]);
 		settings->n_akm_suites = len / sizeof(u32);
 
-		if (len % sizeof(u32))
+		if (len % sizeof(u32)){
+			printk("in nl80211_crypto_settings check NL80211_ATTR_AKM_SUITES not align 32bit\r\n");
 			return -EINVAL;
+		}
 
-		if (settings->n_akm_suites > NL80211_MAX_NR_AKM_SUITES)
+		if (settings->n_akm_suites > NL80211_MAX_NR_AKM_SUITES) {
+			printk("in nl80211_crypto_settings check settings->n_akm_suites failed\r\n");
 			return -EINVAL;
+		}
 
 		memcpy(settings->akm_suites, data, len);
 	}
 
 	if (info->attrs[NL80211_ATTR_PMK]) {
-		if (nla_len(info->attrs[NL80211_ATTR_PMK]) != WLAN_PMK_LEN)
+		if (nla_len(info->attrs[NL80211_ATTR_PMK]) != WLAN_PMK_LEN) {
+			printk("in nl80211_crypto_settings check length of NL80211_ATTR_PMK\r\n");
 			return -EINVAL;
+		}
 		if (!wiphy_ext_feature_isset(&rdev->wiphy,
 					     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK) &&
 		    !wiphy_ext_feature_isset(&rdev->wiphy,
-					     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK))
+					     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK)) {
+			printk("in nl80211_crypto_settings check wiphy_ext_feature_isset 1\r\n");
 			return -EINVAL;
+		}
 		settings->psk = nla_data(info->attrs[NL80211_ATTR_PMK]);
 	}
 
@@ -9994,6 +10552,7 @@ static int nl80211_crypto_settings(struc
 					     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&
 		    !wiphy_ext_feature_isset(&rdev->wiphy,
 					     NL80211_EXT_FEATURE_SAE_OFFLOAD_AP))
+			printk("in nl80211_crypto_settings check wiphy_ext_feature_isset 2\r\n");
 			return -EINVAL;
 		settings->sae_pwd =
 			nla_data(info->attrs[NL80211_ATTR_SAE_PASSWORD]);
@@ -14689,6 +15248,215 @@ static int nl80211_probe_mesh_link(struc
 	return rdev_probe_mesh_link(rdev, dev, dest, buf, len);
 }
 
+#define NL80211_CMD_DEFINE(X) [X] = #X
+
+static const char *nl80211_cmds[] =
+{
+	NL80211_CMD_DEFINE(NL80211_CMD_UNSPEC),
+
+#if 1
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_WIPHY),		/* can dump */
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_WIPHY),
+	NL80211_CMD_DEFINE(NL80211_CMD_NEW_WIPHY),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEL_WIPHY),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_INTERFACE),	/* can dump */
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_INTERFACE),
+	NL80211_CMD_DEFINE(NL80211_CMD_NEW_INTERFACE),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEL_INTERFACE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_KEY),
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_KEY),
+	NL80211_CMD_DEFINE(NL80211_CMD_NEW_KEY),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEL_KEY),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_BEACON),
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_BEACON),
+	NL80211_CMD_DEFINE(NL80211_CMD_START_AP),
+	NL80211_CMD_DEFINE(NL80211_CMD_STOP_AP),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_STATION),
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_STATION),
+	NL80211_CMD_DEFINE(NL80211_CMD_NEW_STATION),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEL_STATION),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_MPATH),
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_MPATH),
+	NL80211_CMD_DEFINE(NL80211_CMD_NEW_MPATH),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEL_MPATH),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_BSS),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_REG),
+	NL80211_CMD_DEFINE(NL80211_CMD_REQ_SET_REG),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_MESH_CONFIG),
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_MESH_CONFIG),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_MGMT_EXTRA_IE /* reserved; not used */),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_REG),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_SCAN),
+	NL80211_CMD_DEFINE(NL80211_CMD_TRIGGER_SCAN),
+	NL80211_CMD_DEFINE(NL80211_CMD_NEW_SCAN_RESULTS),
+	NL80211_CMD_DEFINE(NL80211_CMD_SCAN_ABORTED),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_REG_CHANGE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_AUTHENTICATE),
+	NL80211_CMD_DEFINE(NL80211_CMD_ASSOCIATE),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEAUTHENTICATE),
+	NL80211_CMD_DEFINE(NL80211_CMD_DISASSOCIATE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_MICHAEL_MIC_FAILURE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_REG_BEACON_HINT),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_JOIN_IBSS),
+	NL80211_CMD_DEFINE(NL80211_CMD_LEAVE_IBSS),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_TESTMODE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_CONNECT),
+	NL80211_CMD_DEFINE(NL80211_CMD_ROAM),
+	NL80211_CMD_DEFINE(NL80211_CMD_DISCONNECT),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_WIPHY_NETNS),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_SURVEY),
+	NL80211_CMD_DEFINE(NL80211_CMD_NEW_SURVEY_RESULTS),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_PMKSA),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEL_PMKSA),
+	NL80211_CMD_DEFINE(NL80211_CMD_FLUSH_PMKSA),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_REMAIN_ON_CHANNEL),
+	NL80211_CMD_DEFINE(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_TX_BITRATE_MASK),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_REGISTER_FRAME),
+	NL80211_CMD_DEFINE(NL80211_CMD_FRAME),
+	NL80211_CMD_DEFINE(NL80211_CMD_FRAME_TX_STATUS),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_POWER_SAVE),
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_POWER_SAVE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_CQM),
+	NL80211_CMD_DEFINE(NL80211_CMD_NOTIFY_CQM),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_CHANNEL),
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_WDS_PEER),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_FRAME_WAIT_CANCEL),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_JOIN_MESH),
+	NL80211_CMD_DEFINE(NL80211_CMD_LEAVE_MESH),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_UNPROT_DEAUTHENTICATE),
+	NL80211_CMD_DEFINE(NL80211_CMD_UNPROT_DISASSOCIATE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_NEW_PEER_CANDIDATE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_WOWLAN),
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_WOWLAN),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_START_SCHED_SCAN),
+	NL80211_CMD_DEFINE(NL80211_CMD_STOP_SCHED_SCAN),
+	NL80211_CMD_DEFINE(NL80211_CMD_SCHED_SCAN_RESULTS),
+	NL80211_CMD_DEFINE(NL80211_CMD_SCHED_SCAN_STOPPED),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_REKEY_OFFLOAD),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_PMKSA_CANDIDATE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_TDLS_OPER),
+	NL80211_CMD_DEFINE(NL80211_CMD_TDLS_MGMT),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_UNEXPECTED_FRAME),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_PROBE_CLIENT),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_REGISTER_BEACONS),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_UNEXPECTED_4ADDR_FRAME),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_NOACK_MAP),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_CH_SWITCH_NOTIFY),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_START_P2P_DEVICE),
+	NL80211_CMD_DEFINE(NL80211_CMD_STOP_P2P_DEVICE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_CONN_FAILED),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_MCAST_RATE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_MAC_ACL),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_RADAR_DETECT),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_PROTOCOL_FEATURES),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_UPDATE_FT_IES),
+	NL80211_CMD_DEFINE(NL80211_CMD_FT_EVENT),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_CRIT_PROTOCOL_START),
+	NL80211_CMD_DEFINE(NL80211_CMD_CRIT_PROTOCOL_STOP),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_COALESCE),
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_COALESCE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_CHANNEL_SWITCH),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_VENDOR),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_QOS_MAP),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_ADD_TX_TS),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEL_TX_TS),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_GET_MPP),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_JOIN_OCB),
+	NL80211_CMD_DEFINE(NL80211_CMD_LEAVE_OCB),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_CH_SWITCH_STARTED_NOTIFY),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_TDLS_CHANNEL_SWITCH),
+	NL80211_CMD_DEFINE(NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_WIPHY_REG_CHANGE),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_ABORT_SCAN),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_START_NAN),
+	NL80211_CMD_DEFINE(NL80211_CMD_STOP_NAN),
+	NL80211_CMD_DEFINE(NL80211_CMD_ADD_NAN_FUNCTION),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEL_NAN_FUNCTION),
+	NL80211_CMD_DEFINE(NL80211_CMD_CHANGE_NAN_CONFIG),
+	NL80211_CMD_DEFINE(NL80211_CMD_NAN_MATCH),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_MULTICAST_TO_UNICAST),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_UPDATE_CONNECT_PARAMS),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_SET_PMK),
+	NL80211_CMD_DEFINE(NL80211_CMD_DEL_PMK),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_PORT_AUTHORIZED),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_RELOAD_REGDB),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_EXTERNAL_AUTH),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_STA_OPMODE_CHANGED),
+
+	NL80211_CMD_DEFINE(NL80211_CMD_CONTROL_PORT_FRAME),
+#endif
+};
+
 static int parse_tid_conf(struct cfg80211_registered_device *rdev,
 			  struct nlattr *attrs[], struct net_device *dev,
 			  struct cfg80211_tid_cfg *tid_conf,
@@ -14958,6 +15726,26 @@ out:
 #define NL80211_FLAG_CLEAR_SKB		0x20
 #define NL80211_FLAG_NO_WIPHY_MTX	0x40
 
+
+static int debug_all = 0;
+module_param(debug_all, int, 0640);
+
+static int debug_none = 1;
+module_param(debug_none, int, 0640);
+
+static int debug_cmd_frame = 0;
+module_param(debug_cmd_frame, int, 0640);
+
+static int debug_cmd_set_bss = 0;
+module_param(debug_cmd_set_bss, int, 0640);
+
+static int debug_cmd_set_multicast_to_unicast = 0;
+module_param(debug_cmd_set_multicast_to_unicast, int, 0640);
+
+static int debug_cmd_set_beacon = 0;
+module_param(debug_cmd_set_beacon, int, 0640);
+
+
 static int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
 			    struct genl_info *info)
 {
@@ -14965,11 +15753,16 @@ static int nl80211_pre_doit(const struct
 	struct wireless_dev *wdev;
 	struct net_device *dev;
 
+	if(debug_all) {
+		//printk("nl80211 doit %x %s\r\n", ops->cmd, nl80211_cmds[ops->cmd]?:"UNDEFINED");
+	}
+
 	rtnl_lock();
 	if (ops->internal_flags & NL80211_FLAG_NEED_WIPHY) {
 		rdev = cfg80211_get_dev_from_info(genl_info_net(info), info);
 		if (IS_ERR(rdev)) {
 			rtnl_unlock();
+			printk("need wifi but failed %s\r\n", nl80211_cmds[ops->cmd]?:"UNDEFINED");
 			return PTR_ERR(rdev);
 		}
 		info->user_ptr[0] = rdev;
@@ -14979,6 +15772,7 @@ static int nl80211_pre_doit(const struct
 						  info->attrs);
 		if (IS_ERR(wdev)) {
 			rtnl_unlock();
+			printk("need wdev but failed %s\r\n", nl80211_cmds[ops->cmd]?:"UNDEFINED");
 			return PTR_ERR(wdev);
 		}
 
@@ -14987,6 +15781,7 @@ static int nl80211_pre_doit(const struct
 
 		if (ops->internal_flags & NL80211_FLAG_NEED_NETDEV) {
 			if (!dev) {
+				printk("need netdev but failed %s\r\n", nl80211_cmds[ops->cmd]?:"UNDEFINED");
 				rtnl_unlock();
 				return -EINVAL;
 			}
@@ -14998,6 +15793,7 @@ static int nl80211_pre_doit(const struct
 
 		if (ops->internal_flags & NL80211_FLAG_CHECK_NETDEV_UP &&
 		    !wdev_running(wdev)) {
+			printk("need netdev up but failed %s\r\n", nl80211_cmds[ops->cmd]?:"UNDEFINED");
 			rtnl_unlock();
 			return -ENETDOWN;
 		}
@@ -15014,6 +15810,42 @@ static int nl80211_pre_doit(const struct
 	if (!(ops->internal_flags & NL80211_FLAG_NEED_RTNL))
 		rtnl_unlock();
 
+	if(debug_none)
+		return 0;
+
+	do {
+		if(debug_all)
+			break;
+
+		switch(ops->cmd) {
+		case NL80211_CMD_FRAME:
+			if(!debug_cmd_frame) {
+				return 0;
+			}
+			break;
+		case NL80211_CMD_SET_BSS:
+			if(!debug_cmd_set_bss) {
+				return 0;
+			}
+			break;
+		case NL80211_CMD_SET_MULTICAST_TO_UNICAST:
+			if(!debug_cmd_set_multicast_to_unicast) {
+				return 0;
+			}
+			break;
+		case NL80211_CMD_SET_BEACON:
+			if(!debug_cmd_set_beacon) {
+				return 0;
+			}
+		default:
+			break;
+		}
+	}while(false);
+
+	printk("do cmd %d %s dev is %s and rdev is %d\r\n", ops->cmd, nl80211_cmds[ops->cmd]?:"UNDEFINED",
+			dev?dev->name:"none", rdev?rdev->wdev_id:-1);
+	dump_genlinfo(info);
+
 	return 0;
 }
 
